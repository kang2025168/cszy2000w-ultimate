# -*- coding: utf-8 -*-
# strategy_a.py  (from 交易管理工具2/A策略买卖方法.py)

from dotenv import load_dotenv
load_dotenv()

from config import load_settings
S = load_settings()

import os
import time as t
import random
import traceback
from datetime import datetime, time
from decimal import Decimal, ROUND_HALF_UP

import pymysql
import yfinance as yf

from alpaca.trading.client import TradingClient
from alpaca.trading.requests import MarketOrderRequest, LimitOrderRequest
from alpaca.trading.enums import OrderSide, TimeInForce

from alpaca.data.historical import StockHistoricalDataClient
from alpaca.data.requests import StockLatestTradeRequest


# =====================================================
#                    ENV / FLAGS
# =====================================================
def get_trade_env() -> str:
    return "live" if (S.APP_ENV or "").strip().lower() == "live" else "paper"

def is_after_hours_test_enabled() -> bool:
    return (os.getenv("ALLOW_AFTER_HOURS_TEST") or "0").strip() == "1"


# =====================================================
#                    DB 配置（统一来源：S）
# =====================================================
DB = dict(
    host=S.DB_HOST,
    port=S.DB_PORT,
    user=S.DB_USER,
    password=S.DB_PASSWORD,
    database=S.DB_NAME,
    cursorclass=pymysql.cursors.DictCursor,
    charset="utf8mb4",
    autocommit=True,
)

TABLE = "stock_operations"


# =====================================================
#                  美股交易时间（美西）
# =====================================================
MARKET_OPEN      = time(6, 30)
OPEN_WINDOW_END  = time(6, 40)
PRE_CLOSE_START  = time(12, 55)
MARKET_CLOSE     = time(13, 0)


# =====================================================
#                  价格修复
# =====================================================
def fix_price(p: float) -> float:
    x = Decimal(str(p)).quantize(Decimal("0.01"), rounding=ROUND_HALF_UP)
    if x <= 0:
        x = Decimal("0.01")
    return float(x)


# =====================================================
#                  DB 工具函数
# =====================================================
def db_conn():
    return pymysql.connect(**DB)

def load_one(conn, code: str):
    with conn.cursor() as cur:
        cur.execute(f"SELECT * FROM {TABLE} WHERE stock_code=%s LIMIT 1", (code,))
        return cur.fetchone()

def update_after_sell(conn, stock_code: str, close_price_est: float):
    with conn.cursor() as cur:
        cur.execute(
            f"""
            UPDATE {TABLE}
            SET
                is_bought=0,
                close_price=%s,
                can_sell=0,
                can_buy=0,
                updated_at=NOW()
            WHERE stock_code=%s
            """,
            (float(close_price_est), stock_code),
        )

def update_after_buy(conn, stock_code: str, qty: int, cost_price: float):
    with conn.cursor() as cur:
        cur.execute(
            f"""
            UPDATE {TABLE}
            SET
                is_bought=1,
                qty=%s,
                cost_price=%s,
                can_sell=0,
                can_buy=0,
                updated_at=NOW()
            WHERE stock_code=%s
            """,
            (int(qty), float(cost_price), stock_code),
        )

def rollback_intent(conn, stock_code: str, intent: str):
    with conn.cursor() as cur:
        cur.execute(
            f"""
            UPDATE {TABLE}
            SET last_order_intent=NULL,
                last_order_id=NULL,
                last_order_side=NULL,
                last_order_time=NULL
            WHERE stock_code=%s AND last_order_intent=%s
            """,
            (stock_code, intent),
        )

def mark_not_tradable(conn, stock_code: str, reason: str = "not tradable"):
    reason = (reason or "")[:180]
    with conn.cursor() as cur:
        cur.execute(
            f"""
            UPDATE {TABLE}
            SET can_buy=0,
                updated_at=NOW()
            WHERE stock_code=%s
            """,
            (stock_code,),
        )
    print(f"[DB标记] {stock_code} can_buy=0（原因：{reason}）", flush=True)


# =====================================================
#              幂等/防重复下单（DB锁）
# =====================================================
def make_intent(prefix: str, action: str, code: str, extra: str = "") -> str:
    code = (code or "").strip().upper()
    extra = (extra or "").strip()
    return f"{prefix}:{action}:{code}:{extra}"[:80]

def acquire_intent_lock(conn, stock_code: str, intent: str, side: str) -> bool:
    with conn.cursor() as cur:
        cur.execute(
            f"""
            UPDATE {TABLE}
            SET
                last_order_intent=%s,
                last_order_side=%s,
                last_order_time=NOW()
            WHERE stock_code=%s
              AND (last_order_intent IS NULL OR last_order_intent <> %s)
            """,
            (intent, side, stock_code, intent),
        )
        return cur.rowcount == 1

def mark_order_success(conn, stock_code: str, order_id):
    with conn.cursor() as cur:
        cur.execute(
            f"""
            UPDATE {TABLE}
            SET last_order_id=%s, last_order_time=NOW()
            WHERE stock_code=%s
            """,
            (str(order_id) if order_id else None, stock_code),
        )


# =====================================================
#          Alpaca 错误识别：不可交易/不重试
# =====================================================
class NonRetryableOrderError(Exception):
    """确定性错误：不应重试（例如 not tradable）"""

def _is_not_tradable_error(e: Exception) -> bool:
    msg = str(e).lower()
    if "not tradable" in msg:
        return True
    if "42210000" in msg:
        return True
    return False

def _is_insufficient_error(e: Exception) -> bool:
    msg = str(e).lower()
    # 这些通常重试也没用
    keys = ["insufficient buying power", "insufficient", "not enough buying power", "account is not eligible"]
    return any(k in msg for k in keys)

def _is_non_retryable_error(e: Exception) -> bool:
    return _is_not_tradable_error(e) or _is_insufficient_error(e)


# =====================================================
#                 Alpaca Broker（带重试）
# =====================================================
class Broker:
    def __init__(self):
        api = (S.ALPACA_KEY or "").strip()
        secret = (S.ALPACA_SECRET or "").strip()
        if not api or not secret:
            raise RuntimeError("⛔ 未找到 ALPACA_KEY / ALPACA_SECRET（请检查 .env）")

        env = get_trade_env()
        paper = (env != "live")
        self.env = env
        self.paper = paper

        self.client = TradingClient(
            api_key=api,
            secret_key=secret,
            paper=paper,
            url_override=S.ALPACA_BASE_URL,
        )

        print(f"[券商] 当前环境={env} paper={paper} key前缀={(api[:5] if api else '')}", flush=True)

        if env == "live" and is_after_hours_test_enabled():
            print("[警告] LIVE + ALLOW_AFTER_HOURS_TEST=1：可能在非交易时段触发真实下单！", flush=True)

    def submit_with_retry(self, req, max_retry: int = 5, base_sleep: float = 0.8):
        for i in range(1, max_retry + 1):
            try:
                return self.client.submit_order(req)
            except Exception as e:
                if _is_non_retryable_error(e):
                    raise NonRetryableOrderError(str(e))

                if i == max_retry:
                    raise

                sleep_s = min(base_sleep * (2 ** (i - 1)) + random.uniform(0, 0.6), 10.0)
                print(f"[下单重试] 第{i}次，等待 {sleep_s:.2f}s，错误={e}", flush=True)
                t.sleep(sleep_s)

    def sell_market(self, symbol: str, qty: int):
        req = MarketOrderRequest(
            symbol=symbol,
            qty=float(qty),
            side=OrderSide.SELL,
            time_in_force=TimeInForce.DAY
        )
        return self.submit_with_retry(req)

    def buy_limit(self, symbol: str, qty: int, price: float):
        price = fix_price(price)
        req = LimitOrderRequest(
            symbol=symbol,
            qty=float(qty),
            side=OrderSide.BUY,
            limit_price=float(price),
            time_in_force=TimeInForce.DAY
        )
        return self.submit_with_retry(req)

_broker_singleton = None

def get_broker():
    global _broker_singleton
    if _broker_singleton is None:
        _broker_singleton = Broker()
    return _broker_singleton


# =====================================================
#                 Alpaca Data 行情客户端（单例）
# =====================================================
_data_client_singleton = None

def get_data_client():
    global _data_client_singleton
    if _data_client_singleton is None:
        api = (S.ALPACA_KEY or "").strip()
        secret = (S.ALPACA_SECRET or "").strip()
        if not api or not secret:
            raise RuntimeError("⛔ 未找到 ALPACA_KEY / ALPACA_SECRET（DataClient）")
        _data_client_singleton = StockHistoricalDataClient(api, secret)
    return _data_client_singleton


# =====================================================
#                 行情获取（失败返回 None）
#         ✅ 小优化：本轮缓存，避免同一轮重复请求
# =====================================================
_price_cache = {}  # {"AAPL": (price, ts)}

def _cache_get(code: str, ttl_sec: float = 2.0):
    v = _price_cache.get(code)
    if not v:
        return None
    p, ts = v
    if (t.time() - ts) <= ttl_sec:
        return p
    return None

def _cache_set(code: str, price: float):
    _price_cache[code] = (price, t.time())

def get_price_last(code: str):
    code = code.upper().strip()
    cached = _cache_get(code)
    if cached is not None:
        return cached

    try:
        dc = get_data_client()
        req = StockLatestTradeRequest(symbol_or_symbols=code)
        resp = dc.get_stock_latest_trade(req)
        trade = resp.get(code)
        p = getattr(trade, "price", None)
        if p is not None:
            p = float(p)
            if p > 0:
                p = fix_price(p)
                _cache_set(code, p)
                return p
    except Exception as e:
        err = repr(e).encode("utf-8", "backslashreplace").decode("utf-8")
        print(f"[行情错误] Alpaca 获取失败 {code}: {err}", flush=True)

    # yfinance 兜底：遇到 rate limit 就直接返回 None（别卡住）
    try:
        tk = yf.Ticker(code)
        df = tk.history(period="1d", interval="1m")
        if df is not None and not df.empty:
            p = float(df["Close"].iloc[-1])
            if p > 0:
                p = fix_price(p)
                _cache_set(code, p)
                return p
    except Exception as e:
        msg = str(e).lower()
        if "too many requests" in msg or "rate limit" in msg or "429" in msg:
            print(f"[行情跳过] yfinance rate limit {code}", flush=True)
            return None
        print(f"[行情错误] yfinance 获取失败 {code}: {e}", flush=True)

    return None

def get_open_price(code: str):
    code = code.upper().strip()
    try:
        tk = yf.Ticker(code)
        df = tk.history(period="1d", interval="1m")
        if df is None or df.empty:
            return None
        op = float(df["Open"].iloc[0])
        if op <= 0:
            return None
        return fix_price(op)
    except Exception as e:
        msg = str(e).lower()
        if "too many requests" in msg or "rate limit" in msg or "429" in msg:
            print(f"[开盘价跳过] yfinance rate limit {code}", flush=True)
            return None
        print(f"[行情错误] 获取开盘价失败 {code}: {e}", flush=True)
        return None


# =====================================================
#                 A 策略：卖出
# =====================================================
def strategy_A_sell(stock_code: str):
    stock_code = (stock_code or "").strip().upper()
    if not stock_code:
        return

    try:
        with db_conn() as conn:
            row = load_one(conn, stock_code)
            if not row:
                return

            qty = int(row.get("qty") or 0)
            cost = float(row.get("cost_price") or 0)
            if qty <= 0 or cost <= 0:
                return

            tp = float(row["take_profit_price"]) if row.get("take_profit_price") else fix_price(cost * 1.11)
            sl = float(row["stop_loss_price"])  if row.get("stop_loss_price")  else fix_price(cost * 0.995)

            now = datetime.now().time()
            last = get_price_last(stock_code)
            if last is None:
                print(f"[卖出跳过] {stock_code} 行情为空", flush=True)
                return

            allow_test = is_after_hours_test_enabled()
            broker = get_broker()
            today = datetime.now().strftime("%Y%m%d")

            # 1) 开盘窗口：跳空止盈
            if MARKET_OPEN <= now <= OPEN_WINDOW_END:
                op = get_open_price(stock_code)
                if op is not None and op >= tp:
                    intent = make_intent("A", "SELL_GAP_TP", stock_code, extra=today)
                    if not acquire_intent_lock(conn, stock_code, intent, side="SELL"):
                        return
                    order = broker.sell_market(stock_code, qty)
                    mark_order_success(conn, stock_code, getattr(order, "id", None))
                    update_after_sell(conn, stock_code, close_price_est=op)
                    print(f"[卖出成功-跳空止盈] {stock_code} 开盘价={op} 止盈价={tp} 数量={qty}", flush=True)
                    return

            # 2) 盘中：先止损，再止盈（allow_test=1 时非交易时段也会进入）
            if (MARKET_OPEN <= now < PRE_CLOSE_START) or allow_test:
                if last <= sl:
                    intent = make_intent("A", "SELL_SL", stock_code, extra=today)
                    if not acquire_intent_lock(conn, stock_code, intent, side="SELL"):
                        return
                    order = broker.sell_market(stock_code, qty)
                    mark_order_success(conn, stock_code, getattr(order, "id", None))
                    update_after_sell(conn, stock_code, close_price_est=last)
                    print(f"[卖出成功-止损] {stock_code} 最新价={last} 止损价={sl} 数量={qty}", flush=True)
                    return

                if last >= tp:
                    intent = make_intent("A", "SELL_TP", stock_code, extra=today)
                    if not acquire_intent_lock(conn, stock_code, intent, side="SELL"):
                        return
                    order = broker.sell_market(stock_code, qty)
                    mark_order_success(conn, stock_code, getattr(order, "id", None))
                    update_after_sell(conn, stock_code, close_price_est=last)
                    print(f"[卖出成功-止盈] {stock_code} 最新价={last} 止盈价={tp} 数量={qty}", flush=True)
                    return
                return

            # 3) 收盘前：强制市价全平
            if PRE_CLOSE_START <= now <= MARKET_CLOSE:
                intent = make_intent("A", "SELL_FORCE", stock_code, extra=today)
                if not acquire_intent_lock(conn, stock_code, intent, side="SELL"):
                    return
                order = broker.sell_market(stock_code, qty)
                mark_order_success(conn, stock_code, getattr(order, "id", None))
                update_after_sell(conn, stock_code, close_price_est=last)
                print(f"[卖出成功-收盘强平] {stock_code} 最新价={last} 数量={qty}", flush=True)
                return

    except Exception as e:
        print(f"[卖出错误] {stock_code} {e}", flush=True)
        traceback.print_exc()
        return


# =====================================================
#                 A 策略：买入
# =====================================================
def strategy_A_buy(stock_code: str):
    stock_code = (stock_code or "").strip().upper()
    if not stock_code:
        return

    try:
        with db_conn() as conn:
            with conn.cursor() as cur:
                cur.execute(
                    f"""
                    SELECT weight, trigger_price, is_bought, can_buy
                    FROM {TABLE}
                    WHERE stock_code=%s
                    LIMIT 1
                    """,
                    (stock_code,),
                )
                row = cur.fetchone()

            if not row:
                return
            if int(row.get("is_bought") or 0) == 1:
                return
            if int(row.get("can_buy") or 0) != 1:
                return

            weight = float(row.get("weight") or 0)
            price  = float(row.get("trigger_price") or 0)
            if weight <= 0 or price <= 0:
                return

            broker = get_broker()
            acct = broker.client.get_account()

            buying_power = float(acct.buying_power)
            usable = buying_power * 0.8
            cash = usable * weight

            # ✅ 小优化：避免浮点导致 qty=0 来回跳
            qty = int(cash // price)
            if qty <= 0:
                return

            today = datetime.now().strftime("%Y%m%d")
            intent = make_intent("A", "BUY", stock_code, extra=f"{today}_{price}")

            if not acquire_intent_lock(conn, stock_code, intent, side="BUY"):
                return

            # ✅ 再确认一次状态，避免刚被别的进程改掉
            latest = load_one(conn, stock_code) or {}
            if int(latest.get("can_buy") or 0) != 1 or int(latest.get("is_bought") or 0) == 1:
                rollback_intent(conn, stock_code, intent)
                return

            buy_price = fix_price(price + 0.01)

            try:
                order = broker.buy_limit(stock_code, qty, buy_price)
            except NonRetryableOrderError as e:
                print(f"[买入跳过-不可重试] {stock_code} {e}", flush=True)
                rollback_intent(conn, stock_code, intent)

                # not tradable -> can_buy=0；insufficient -> 不禁用，只回滚让你下次还有机会
                if "not tradable" in str(e).lower() or "42210000" in str(e).lower():
                    mark_not_tradable(conn, stock_code, reason=str(e))
                return
            except Exception as e:
                print(f"[买入错误] {stock_code} 下单失败：{e}（回滚intent）", flush=True)
                rollback_intent(conn, stock_code, intent)
                raise

            mark_order_success(conn, stock_code, getattr(order, "id", None))
            update_after_buy(conn, stock_code, qty=qty, cost_price=buy_price)

            print(f"[买入成功] {stock_code} 数量={qty} 价格={buy_price} 订单ID={getattr(order,'id',None)}", flush=True)

    except Exception as e:
        print(f"[买入异常] {stock_code} {e}", flush=True)
        traceback.print_exc()
        return